@inject IJSRuntime JsRuntime;
<CascadingValue Value="@WasClicked">
    <div id="@Id" @onmousedown="@MouseDown" @onmousemove="@MouseMove" @onmouseup="@MouseUp" style="transform:translate3d(@(MyPosition.Left)px, @(MyPosition.Top)px, 0px);@Style" class="@Class">
        @ChildContent
    </div>
</CascadingValue>

@code
{
    [Parameter] private string Class { get; set; }
    [Parameter] private string Style { get; set; }
    [Parameter] private bool BoundToContainer { get; set; }
    [Parameter] private bool UseHandle { get; set; }
    [Parameter] private RenderFragment ChildContent { get; set; }
    [Parameter] private Action<TopAndLeft> Results { get; set; }
    [CascadingParameter] private Guid ParentId { get; set; } = new Guid();
    private Guid Id { get; set; } = new Guid();
    private Size MySize { get; set; } = new Size();
    private Size ParentSize { get; set; } = new Size();
    private TopAndLeft MyPosition { get; set; } = new TopAndLeft();
    private TopAndLeft MouseOffsets = new TopAndLeft();
    private EventHandler WasClicked { get; set; }
    private bool CanMove = false;

    protected override Task OnInitAsync()
    {
        Id = Guid.NewGuid();
        if (UseHandle)
        {
            WasClicked += OnWasClicked;
        }
        return base.OnInitAsync();
    }

    private void MouseUp()
    {
        Results.Invoke(MyPosition);
    }

    
    private void OnWasClicked(Object Sender, EventArgs e)
    {
        CanMove = true;
    }

    private async Task MouseDown(UIMouseEventArgs e)
    {
        if (BoundToContainer)
        {
            var parentSize = await JsRuntime.InvokeAsync<string>("BlazorDragable.getSize", ParentId.ToString());
            ParentSize = System.Text.Json.Serialization.JsonSerializer.Parse<Size>(parentSize);
        }
        var size = await JsRuntime.InvokeAsync<string>("BlazorDragable.getSize", Id.ToString());
        MySize = System.Text.Json.Serialization.JsonSerializer.Parse<Size>(size);
        var mouse = await JsRuntime.InvokeAsync<string>("BlazorDragable.getBoundingClientRect", Id.ToString());
        var mouseOffset = System.Text.Json.Serialization.JsonSerializer.Parse<TopAndLeft>(mouse);

        MouseOffsets.Top = (mouseOffset.Top - e.ClientY) * -1;
        MouseOffsets.Left = (mouseOffset.Left - e.ClientX) * -1;
        if (!UseHandle)
        {
            CanMove = true;
        }

    }

    private async Task MouseMove(UIMouseEventArgs e)
    {
        if (e.Buttons == 1)
        {
            if (!CanMove)
            {
                return;
            }
            e.ClientY -= MouseOffsets.Top;
            e.ClientX -= MouseOffsets.Left;

            if (BoundToContainer)
            {
                var x = await JsRuntime.InvokeAsync<string>("BlazorDragable.getOffsets", ParentId.ToString());
                var clientOffset = System.Text.Json.Serialization.JsonSerializer.Parse<TopAndLeft>(x);
                e.ClientX -= clientOffset.Left;
                e.ClientY -= clientOffset.Top;
                if ((e.ClientX) < 0)
                {
                    e.ClientX = 0;
                }
                if ((e.ClientY) < 0)
                {
                    e.ClientY = 0;
                }

                if ((e.ClientX + MySize.Width) > ParentSize.Width)
                {
                    e.ClientX = ParentSize.Width - MySize.Width;
                }
                if ((e.ClientY + MySize.Height) > ParentSize.Height)
                {
                    e.ClientY = ParentSize.Height - MySize.Height;
                }
            }

            MyPosition.Top = e.ClientY;
            MyPosition.Left = e.ClientX;
        }
        else
        {
            CanMove = false;
        }
    }
}
